#!/usr/bin/python

from armory2.armory_main.models import BaseDomain, Domain
from armory2.armory_main.included.ModuleTemplate import ToolTemplate
from armory2.armory_main.included.utilities.color_display import display, display_error, display_warning
import os
import json


class Module(ToolTemplate):
    '''
    This module uses the Ruby version of Aquatone. You can usually install it with "gem install aquatone"

    '''
    name = "aquatone-discover"
    binary_name = "aquatone-discover"

    def set_options(self):
        super(Module, self).set_options()

        self.options.add_argument("-d", "--domain", help="Target domain for aquatone")
        self.options.add_argument("-f", "--file", help="Import domains from file")
        self.options.add_argument(
            "-i",
            "--import_database",
            help="Import domains from database",
            action="store_true",
        )
        self.options.add_argument(
            "-r",
            "--rescan",
            help="Run aquatone on hosts that have already been processed.",
            action="store_true",
        )
        self.options.set_defaults(timeout=None)

    def get_targets(self, args):
        """
        This module is used to build out a target list and output file list, depending on the arguments. Should return a
        list in the format [(target, output), (target, output), etc, etc]
        """
        targets = []

        if args.domain:
            domain, created = BaseDomain.objects.get_or_create(name=args.domain)
            targets.append(domain.name)

        elif args.file:
            domainsFile = open(args.file).read().split("\n")
            for d in domainsFile:
                if d:
                    domain, created = BaseDomain.objects.get_or_create(name=d)
                    targets.append(domain.name)

        elif args.import_database:
            if args.rescan:
                all_domains = BaseDomain.get_set(scope_type="passive")
            else:
                all_domains = BaseDomain.get_set(tool=self.name, args=args.tool_args, scope_type="passive")
            for d in all_domains:
                targets.append(d.name)

        else:
            print("You need to supply domain(s).")

        output_path = os.path.join(
            self.base_config["ARMORY_BASE_PATH"], "output", "aquatone"
        )

        if not os.path.exists(output_path):
            os.makedirs(output_path)

        res = []
        for t in targets:
            res.append(
                {"target": t, "output": "{}/{}/hosts.json".format(output_path, t)}
            )

        return res

    def build_cmd(self, args):
        """
        Create the actual command that will be executed. Use {target} and {output} as placeholders.
        """
        cmd = self.binary + " -d {target} "

        if args.tool_args:
            cmd += args.tool_args

        return cmd

    def pre_run(self, args):
        output_path = os.path.join(self.base_config["ARMORY_BASE_PATH"], "output")

        self.orig_home = os.environ["HOME"]

        os.environ["HOME"] = output_path

    def process_output(self, cmds):
        """
        Process the output generated by the earlier commands.
        """
        for cmd in cmds:
            d, created = BaseDomain.objects.get_or_create(name=cmd['target'])
            d.add_tool_run(self.name, self.args.tool_args)
            try:
                data2 = json.loads(open(cmd["output"]).read())

                for sub, ip in data2.items():
                    created = False
                    new_domain = sub.lower()

                    if new_domain:
                        subdomain, created = Domain.objects.get_or_create(name=new_domain)
            except Exception as e:
                display_error("Couldn't find file: {}".format(cmd["output"]))
        

    def post_run(self, args):

        os.environ["HOME"] = self.orig_home
